# 04. 정렬
> Keyword : 버블정렬, 선택정렬

## 04-0 정렬
- 버블 : 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬
- 선택 : 대상에서 가장 크거나 작은 데이터 찾아가 선택을 반복하면서 정렬
- 삽입 : 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬
- 퀵 : pivot 값을 선정해 해당 값을 기준으로 정렬
- 병합 : 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬
- 기수 : 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬

## 04-1 버블 정렬
- 두 인접한 데이터의 크기를 비교해 정렬
- O(n^2)으로 속도 느림
- 루프를 돌면서 인접한 데이터 간의 swap 연산으로 정렬

## 04-2 선택 정렬
- 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
- O(n^2)으로 속도 느리고 복잡. -> 잘 사용 안 함
- 최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와 swap

## 04-3 삽입 정렬
- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬
- O(n^2)으로 속도 느림. 구현 쉬움
- 선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입
- 삽입 위치 탐색할 때 이진 탐색 같은 탐색 알고리즘 쓰면 시간 복잡도 줄일 수 있음

## 04-4 퀵 정렬
- 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해서 정렬
- 기준값이 어떻게 선정되는지가 중요. O(nlogn)
- pivot을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬
- 재귀 형태로 구현

### 퀵 정렬 구현하기
1. 중간 위치를 pivot으로 설정하고 맨 앞의 값과 swap
2. pivot 제외한 그룹에서 왼쪽 끝을 i, 오른쪽 끝을 j로 설정
3. j를 이동 - j보다 pivot이 크면 j--
4. i를 이동 - i가 pivot보다 작으면서 j가 더 크면 i++
5. i, j 멈추면 swap
6. 이 때, i, j가 만나면 해당 위치와 pivot swap
7. 분리 집합에서 다시 pivot 선정해서 분리집합 1개 이하 될 때까지 반복

## 04-5 병합 정렬
## 04-6 기수 정렬

