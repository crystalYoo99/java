# Chapter 20. OOP와 FP의 조화 : 자바와 스칼라 비교
> Keyword : 스칼라, 함수, 클로저, 커링, 클래스와 트레이트

## 20.1 스칼라 소개
#### 스칼라
- 객체지향과 함수형 프로그래밍을 혼합한 언어
- 스칼라는 복잡한 형식 시스템, 형식 추론, 패턴 매칭, 도메인 전용 언어를 단순하게 정의할 수 있는 구조 등을 제공
- 모든 자바 라이브러리 사용 가능
- 스칼라는 자바에 비해 더 다양하고 심화된 함수형 기능을 제공

### 20.1.1 Hello beer
#### 명령형 스칼라
- 자바에서는 클래스 내에 main 메서드를 선언하지만 스칼라에서는 object로 직접 싱글턴 객체를 만들 수 있다
-  object로 클래스를 정의하고 동시에 인스턴스화 가능. 한번에 단 하나의 인스턴스만 생성됨.
- object 내부에 선언된 메서드는 정적 메서드로 간주
#### 문자열 보간법
- 문자열 자체에 변수와 표현식을 바로 삽입하는 기능
- 문자열에 접두어 s를 붙인다
```java
println(s"Hello ${n} bottles of beer")
```
#### 함수형 스칼라
- 스칼라에서는 모든 것이 객체. 기본형이 없다. 완전한 객체지향 언어.
- to() : 다른 Int를 인수로 받아 범위를 반환
- foreach() : 자바의 forEach()랑 비슷. 범위에 사용할 수 있는 메서드로 람다 표현식을 인수로 받아서 각 요소에 적용
- 람다 표현식 문법은 자바와 비슷. -> 대신 => 사용

### 20.1.2 기본 자료구조 : 리스트, 집합, 맵, 튜플, 스트림, 옵션
#### 컬렉션 만들기
- -> : 키를 값에 대응시켜 맵을 만듦
- 변수 형식을 지정하지 않음. 스칼라는 자동으로 변수형을 추론하는 기능이 있다
- 스칼라는 코드를 정적으로 확인한다! 즉, 모든 변수의 형식은 컴파일을 할 때 결정된다
- var 대신 val 사용. val은 변수가 읽기 전용(자바의 final처럼), var는 읽고 쓸 수 있는 변수

#### 불변과 가변
- 컬렉션은 기본적으로 불변. 만들면 변경할 수 없다.
- 스칼라의 불변 컬렉션을 갱신할 때는 기존 버전과 가능한 한 많은 자료를 공유하는 새로운 컬렉션을 만드는 방법 사용 -> 암묵적인 데이터 의존성 줄일 수 잇음
- 스칼라에서는 불변 컬렉션만 사용하도록 강제하는 것은 아니다

#### 컬렉션 사용하기
- 스칼라의 컬렉션 동작은 스트림 API와 비슷
- 인픽스 개념과 언더스코어(_) : 언더스코어는 인수로 대치됨. ex) _.length()는 l => l.length()
- filter, map으로 전달된 함수에서 언더스코어는 처리되는 행으로 바운드됨
- par() : 자바에서 parallel로 파이프라인 병렬로 실행하듯 par 메서드로 비슷한 기능 제공

#### 튜플
- 스칼라는 튜플 축약어 제공
- 접근자 _숫자로 튜플 요소에 접근 가능
```java
val book = (2018, "Modern Java in Action", "Manning") //(Int, String, String 형식의 튜플
val numbers = (42, 1337, 0, 3, 14) // (Int, Int, Int, Int, Int) 형식의 튜플
        
println(book._1) // 2018 출력
println(numbers._4) / 3 출력
```

#### 스트림
- 리스트, 집합, 맵, 튜플은 적극적으로(즉시) 평가
- 자바의 스트림은 요청할 때만 평가. 게으른 평가
- 스칼라의 스트림도 게으르게 평가되는 자료구조. 자바보다 다양한 기능 제공
- 스칼라의 스트림은 이전 요소가 접근할 수 있도록 기존 계산값을 기억
- 스칼라의 스트림은 인덱스를 제공.

#### 옵션
- 스칼라의 Option은 자바의 Optional과 같은 기능 제공
-  null 대신 Optional을 사용하면 null 포인터 예외 방지

## 20.2 함수
### 20.2.1 스칼라의 일급 함수
- 스칼라의 함수는 어떤 작업을 수행하는 일련의 명령어 그룹
- 스칼라의 함수는 일급값
- 함수를 인수로 전달하거나, 결과로 반환하거나, 변수에 저장 가능
- 함수 형식은 자바 함수 디스크립터의 개념을 표현하는 편의 문법(즉, 함수형 인터페이스에 선언된 추상 메서드의 시그니처를 표현하는 개념)이다
### 20.2.2 익명 함수와 클로저
#### 익명 함수
- 익명 함수는 자바의 람다 표현식과 달리 비지역 변수 기록에 제한을 받지 않는다.
- 자바의 람다 표현식으로 함수형 인터페이스의 인스턴스를 만들 수 있듯, 스칼라도 비슷한 방식을 지원
#### 클로저
- 함수의 비지역 변수를 자유롭게 참조할 수 있는 함수의 인스턴스
- 자바의 람다 표현식에는 람다가 정의된 메서드의 지역 변수를 고칠 수 없다는 제약이 있다. 암시적으로 final로 취급. 람다는 변수가 아닌 값을 닫는다
- 스칼라의 익명 함수는 값이 아니라 변수를 캡처할 수 있다

### 20.2.3 커링
- 커링은 여러 인수를 받는 함수를 일부 인수를 받는 여러 함수로 분리하는 기법
- x, y라는 두 인수를 가진 f라는 함수가 있을 때 이는 하나의 인수를 받는 g라는 함수 그리고 g라는 함수는 다시 나머지 인수를 받는 함수로 반환되는 상황으로 볼 수 있다
- 스칼라는 커리 형식으로 분할하는 과정을 자동으로 처리하는 특수 문법을 제공. ex) (x: Int) (y: Int)
```java
def multiplyCurry(x :Int)(y : Int) = x * y // 커리된 함수 정의
val r = multiplyCurry(2)(10) // 커리된 함수 호출
```
## 20.3 클래스와 트레이트
### 20.3.1 간결성을 제공하는 스칼라의 클래스
#### 게터와 세터
스칼라에서는 생성자, 게터, 세터가 암시적으로 생성된다
### 20.3.2 스칼라 트레이트와 자바 인터페이스
#### 트레이트
- 스칼라의 트레이트는 자바의 인터페이스를 대체
- 트레이트로 추상 메서드와 기본 구현을 가진 메서드 두 가지 모두 정의 가능
- 객체를 인스턴스화할 때 메서드 상속 기능을 지원
- 다중 상속을 지원하므로 자바의 인터페이스와 디폴트 메서드 기능이 합쳐진 것으로 이해 가능
- 자바 인터페이스와는 달리 객체 트레이트는 인스턴스화 과정에서도 조합 가능

## 20.4 마치며
- 자바와 스칼라는 객체지향과 함수형 프로그래밍 모두를 하나의 프로그래밍 언어로 수용한다. 두 언어 모두 JVM에서 실행되며 넓은 의미에서 상호운용성을 갖는다.
- 스칼라는 자바처럼 리스트, 집합, 맵, 스트림, 옵션 등의 추상 컬렉션을 제공한다. 또한 튜플도 추가로 제공한다.
- 스칼라는 자바에 비해 풍부한 함수 관련 기능을 제공한다. 스칼라는 함수 형식, 지역 변수에 접근할 수 있는 클로저, 내장 커링 형식 등을 지원한다.
- 스칼라의 클래스는 암묵적으로 생성자, 게터, 세터를 제공한다.
- 스칼라는 트레이트를 지원한다. 트레이트는 필드와 디폴트 메서드를 포함할 수 있는 인터페이스다.

