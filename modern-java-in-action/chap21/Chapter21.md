# Chapter 21. 결론 그리고 자바의 미래
> 자바 8 keyword : 동작 파라미터화, 람다, 메서드참조, 스트림, CompletableFuture, Optional, Flow API, 디폴트 메서드
> 자바 9 keyword : 새 모듈 시스템, module-info.java
> 자바 10 keyword : 지역 변수형 추론, var

## 21.1 자바 8의 기능 리뷰
#### 자바 8의 변화 원인
1. 멀티코어 프로세서의 파워를 충분히 활용해야 한다는 것. 코드를 병렬로 실행해야 더 빨라짐.
2. 선언형으로 데이터 처리하는 추세. 간결하게 데이터 컬렉션을 처리하려면 불변값을 생산할 수 있는 불변 객체와 불변 컬렉션이 필요.
### 21.1.1 동작 파라미터화 (람다와 메서드 참조)
- 함수형 프로그래밍에서 지원하는 메서드로 코드 블록을 전달하는 기법
- apple -> apple.getWeight( ) > 150 같은 람다 코드 전달 가능
- Apple: :isHeavy 같은 기존 메서드의 메서드 참조 전달 가능
- 메서드로 전달되는 값은 Function<T, R>, Predicate<T>, BiFunction<T, U, R> 등의 형식을 가지며 메서드를 수신한 코드에서는 apply, test 등의 메서드로 코드 실행

### 21.1.2 스트림
- 스트림 API는 연산을 파이프라인이라는 게으른 형식의 연산으로 구성하고 한 번의 탐색으로 파이프라인의 모든 연산을 수행
- 스트림의 parallel 메서드는 스트림을 병렬로 처리하도록 지정하는 역할
- 외부 반복 대신 내부 반복을 지원하는 메서드 등이 함수형 개념의 핵심

### 21.1.3 CompletableFuture 클래스
#### Future 인터페이스
- 자바 5부터 Future 인터페이스를 제공
- Future를 이용하면 여러 작업이 동시에 실행될 수 있도록 다른 스레드나 코어로 작업을 할당
- 멀티코어 잘 활용 가능.
-  다른 작업을 생성한 기존 작업에서 결과가 필요할 때는 get 메서드를 호출해서 생성된 Future가 완료(즉, 결과값을 계산)될 때까지 기다릴 수 있다

#### CompletableFuture
- Future를 구현
- CompletableFuture와 Future의 관계는 스트림과 컬렉션의 관계와 같다
- CompletableFuture는 Future와 관련한 공통 디자인 패턴을 함수형 프로그래밍으로 간결하게 표현할 수 있도록 thenCompose, thenCombine, allOf 등을 제공.
- 명령형에서 발생하는 불필요한 코드를 피할 수 있다.

### 21.1.4 Optional 클래스
- T 형식의 값을 반환하거나 값이 없음을 의미하는 Optional.empty라는 정적 메서드를 반환
- 프로그램을 쉽게 이해하고 문서화하는 데 큰 도움
- NullPointerException이 발생하지 않음
- map, filter, ifPresent 제공. 값을 내부적으로 검사
- 자바9 : stream(), or(), ifPresentOrElse() 등 추가

### 21.1.5 Flow API
- 자바9 : 리액티브 스트림과 리액티브 당김 기반 역압력 프로토콜을 표준화
- 호환성을 높일 수 있도록 라이브러리가 구현할 수 있는 네 개의 인터페이스 Publisher, Subscriber, Subscription, Processor를 포함
#### 역압력 프로토콜
소비자가 빠른 생산자를 대응하지 못해 발생하는 문제를 방지하는 기법

### 21.1.6 디폴트 메서드
- 메서드의 기본 구현을 제공.
- 인터페이스가 바뀌어도 사용자는 신경쓸 필요가 없어짐

## 21.2 자바 9 모듈 시스템
- 자바 9에서는 새 언어 기능 추가는 없었지만 자바8에서 시작된 여러 기능 강화
- ex. 스트림의 takeWhile, dropWhile과 CompletableFuture의 completeOnTimeout 등
- 자바 9의 핵심은 새 모듈 시스템
- 새 모듈 시스템에서는 module-info.java 파일이 추가. 언어적으로는 바뀐 것 없음.
- 모듈 시스템 덕분에 아키텍처 관점에서 애플리케이션을 설계하고 구현하는 방식이 바뀌었고 하위 부분간의 경계와 상호작용 방법 정의가 명확해짐
- 자바 모듈 시스템 덕분에 사물인터넷 애플리케이션이나 클라우드에서 자바 런타임을 사용할 수 있게 됨

#### 자바 모듈 시스템이 제공하는 장점
- 안정적 설정 : 모듈 요구사항을 명시적으로 선언함으로 의존성 빠짐, 충돌, 순환 등의 문제를 런타임이 아닌 빌드 과정에서 일찍 확인 가능
- 강한 캡슐화 : 자바 모듈 시스템은 특정 패키지만 노출한 다음 각 모듈에서 공개할 부분과 내부 구현의 영역 접근 분리 가능
- 보안성 개선 : 사용자가 모듈의 특정 부분을 사용할 수 없도록 함으로 해커가 보안 제어를 뚫기 어려워짐
- 성능 개선 : 클래스가 런타임이 로드된 다른 클래스를 참조하는 상황보다는 적은 수의 컴포넌트를 참조할 때 최적화 기술이 더 효과를 발휘
- 확장성 : 자바 모듈 시스템은 자바 SE 플랫폼을 작은 부분으로 나눔으로 실행중인 애플리케이션에서 필요한 부분만 사용 가능

## 21.3 자바 10 지역 변수형 추론
- 엄격한 형식 지정이 조금 느슨해짐
- 컨텍스트로 형식을 유추할 수 있는 상황에서는 제네릭의 형식 파라미터 생략 가능
- 형식이 생략되면 컴파일러가 생략된 형식을 추론
- var : 지역 변수의 형식을 var 키워드로 대체.  컴파일러가 변수 할당문의 오른쪽 내용을 기초로 형식을 추론
- 초깃값이 없을 때는 var을 사용할 수 없음

## 21.4 자바의 미래
### 21.4.1 선언 사이트 변종
#### 사용 사이트 변종
- 자바에서는 제네릭의 서브형식을 와일드카드로 지정할 수 있는 유연성을 허용  
- ? extends, ?super
- ex. List<? extends Number> numbers = new ArrayList<Integer>();
#### 선언 사이트 변종
- 제네릭 클래스를 정의할 때 프로그래머가 변종을 지정 가능
- 변종적인 클래스에서 이 기능을 유용하게 사용 (Iterator는 공변적, Comparator는 반변적)
- C#, 스칼라 등에서 지원
- ? extends, ?super 사용하지 않고 클래스를 정의할 때 이와 같은 규격명세를 표현
### 21.4.2 패턴 매칭
- switch를 개선한 기능
- ‘이 값이 주어진 클래스의 인스턴스인가?’라는 질문을 직접 할 수 있으며 객체의 필드가 어떤 값을 가지고 있는지도 재귀적으로 물을 수 있다
#### 전통적인 객체지향 디자인 vs. 함수형 프로그래밍
- 전통적인 객체지향 디자인 : switch 대신 방문자 패턴 등을 사용할 것을 권장
- 함수형 프로그래밍 : 데이터 형식의 값에 패턴 매칭을 적용
- 방문자 패턴에서는 데이터 형식에 종속된 제어 흐름이 switch 가 아닌 메서드에 의해 결정
### 21.4.3 풍부한 형식의 제네릭
### 21.4.4 더 근본적인 불변성 지원
### 21.4.5 값 형식

### 21.5 더 빠르게 발전하는 자바

### 21.6 결론
