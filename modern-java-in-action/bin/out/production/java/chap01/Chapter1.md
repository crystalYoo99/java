# Chapter 1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?
> Keyword : 스트림, 메서드 참조, 람다, 디폴트메서드


## 1.1 역사의 흐름은 무엇인가?
1996년에 JDK 1.0이 발표된 이후 자바는 새로운 기능과 더불어 계속 발전해왔다.  
멀티코어 CPU 대중화 같은 하드웨어적 변화도 영향을 미쳤다.

자바는 병렬 실행 환경을 위한 방향으로 진화하려 노력해왔다.  
자바 1.0 : 스레드, lock 메모리모델  
자바 5 : thread pool, 병렬 실행 컬렉션  
자바 7 : 포크/조인 프레임워크  
자바 8 : 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법 제공  
자바 9 : 리액티브 프로그래밍, RxJava


### 자바 8의 요구사항
- 간결한 코드, 멀티코어 프로세서의 쉬운 활용

### 자바 8의 핵심 변화
- 스트림 API
- 동작 파라미터화 (메서드 참조와 람다)
- 인터페이스의 디폴트 메서드


## 1.2 왜 아직도 자바는 변화하는가?
새로운 언어가 등장하며 진화하지 않은 기존 언어는 사장되었다.  
완벽한 언어는 존재하지 않고 모든 언어에는 장단점이 있다.
- C, C++ : 프로그래밍 안전성은 부족. 작은 런타임 풋프린트 덕분에 OS, 다양한 임베디드 시스템에서 사용.
- C+, java : 안전한 형식의 언어. 런타임 풋프린트에 여유있는 애플리케이션에서 사용.

### 프로그래밍 언어 생태계와 자바
- 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작
- 캡슐화, 객체지향으로 각광받음
- 자바는 계속 새 기능을 추가하며 자리를 유지하고 있다.
- 빅데이터의 효과적 처리를 위한 병렬 프로세싱 활용이 중요해지면서 자바8에서 병렬성을 활용하는 코드를 제공.

### 자바8의 세가지 프로그래밍 개념
- 스트림 API
- 동작 파라미터화로 메서드에 코드 전달하기
- 병렬성과 공유 가변 데이터

자바8의 가장 큰 변화는 함수형 프로그래밍을 도입했다는 것  
언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다.



## 1.3 자바 함수
프로그래밍 언어에서의 함수 : 메서드 특히, static method(정적 메서드)와 같은 의미로 사용  
자바의 함수 : 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수. 자바 8은 함수를 새로운 값의 형식으로 추가함.

### 메서드와 람다를 일급시민으로
메서드와 람다를 일급값으로 해서 값으로 취급할 수 있게 됨.


#### 메서드 참조 (::)
메서드를 전달할 수 있다
```java
//기존의 숨겨진 파일 필터링 방식
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    public boolean accept(File file) {
        return file.isHidden();
    }
});

// 메서드 참조
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

#### 람다 (익명함수)
람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍이라고 한다.
즉, '함수를 일급값으로 넘겨주는 프로그램'을 구현한다고 한다.
```java
(int x) -> x + 1
```

### 메서드전달에서 람다로
한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다.
```java
//메서드전달
List<Apple> greenApples=filterApples(inventory,FilteringApples::isGreenApple);
// 람다
List<Apple> greenApples=filterApples(inventory,(Apple a) -> GREEN.equals(a.getColor()));

// 람다 사용시 필요 없어짐
public static boolean isGreenApple(Apple apple) {
    return GREEN.equals(apple.getColor());
}
```

## 1.4 스트림
‘컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제’와 ‘멀티코어 활용 어려움’을 해결

### 컬렉션과 스트림
- 컬렉션은 외부반복 : 반복 과정을 직접 처리. for-each 루프로 각 요소를 반복하면서 작업 수행
- 스트림은 내부반복 : 루프 신경쓸 필요 없이 라이브러리 내부에서 모든 데이터를 처리.
- 컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점 / 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점.

### 멀티스레딩은 어렵다
- 스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다. 멀티스레드는 공유자원을 사용하기 때문에 공유 자원에 대한 처리가 필요.  
- 스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경 제공. parallelStream()
- 스트림과 람다 표현식을 이용하면 '병렬성을 공짜로' 얻을 수 있다.

```java
import static java.util.stream.Collectors.groupingBy;
Map<Currency, List<Transaction>> transactionsByCurrencies =
        transactions.stream()
        .filter((Transaction t) -> t.getPrice() > 1000) //필터링
        .collect(groupingBy(Transaction::getCurrency)); //그룹화
```

## 1.5 디폴트 메서드와 자바 모듈
### 디폴트 메서드
- 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능.
- 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함됨.
- 기존의 코드를 건드리지 않고 인터페이스 설계 확장 가능.
- 인터페이스를 쉽게 바꿀 수 있게 됨.
- 인터페이스, 라이브러리의 간결성 유지 및 재컴파일을 줄이는데 활용.
```java
// List 인터페이스에 sort 디폴트 메서드가 있어서 
// 자바8부터는 List를 구현하는 모든 클래스가 sort를 구현하지 않아도 됨.
default void sort(Comparator<? super E> c) {
    Collections.sort(this, c);
}
```

### 모듈
자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공해서 패키지 모음을 포함하는 모듈을 정의할 수 있다.
모듈로 JAR 같은 컴포넌트에 구조를 적용할 수 있고, 문서화와 모듈 확인 작업이 용이해졌다.

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어
스트림 API가 활용하고 있는 아이디어
1) 메서드와 람다를 일급값으로 사용하는 것
2) 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드를 호출할 수 있다는 것

다른 아이디어
1) Optional\<T> 클래스 : NullPointer 예외 피할 수 있음
2) 패턴 매칭


## 1.7 마치며
- 자바8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능 제공
- 기존의 자바 프로그래밍 기법으로는 멀티코어 프로세서를 온전히 활용하기 어렵다.
- 함수는 일급값. 메서드를 어떻게 함수형값으로 넘겨주는지, 익명 함수(람다)를 어떻게 구현하는지 기억.
- 자바8의 스트림 개념 중 일부는 컬렉션에서 가져옴. 스트림과 컬렉션을 적절히 활용하면 스트림의 인수를 병렬로 처리할 수 있고 더 가독성 좋은 코드를 구현할 수 있다.
- 기존 자바 기능으로는 대규모 컴포넌트 기반 프로그래밍과 진화하는 시스템의 인터페이스를 적절히 대응하기 어려웠음. 자바 9에서는 모듈을 이용해서 시스템의 구조를 만들 수 있고 디폴트 메소드를 이용해서 기존 인터페이스를 구현하는 클래스를 바꾸지 않고도 인터페이스를 변경할 수 있다.
- 함수형 프로그래밍에서 null 처리 방법과 패턴 매칭 활용 등 흥미로운 기법을 발견함.