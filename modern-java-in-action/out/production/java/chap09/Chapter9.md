# Chapter 9. 리팩터링, 테스팅, 디버깅
> Keyword : 리팩터링, OODP, 람다 표현식, 테스팅, 디버깅, 스택 트레이스

## 9.1 가독성과 유연성을 개선하는 리팩터링
###  람다, 메서드 참조, 스트림을 활용해서 코드 가독성을 개선할 수 있는 3가지 예제
#### 1. 익명 클래스를 람다 표현식으로 리팩터링하기
- 하나의 추상 메서드를 구현하는 익명 클래스는 람다 표현식으로 리팩터링
- 단, this, super, 섀도 변수 등 미묘하게 의미상 다른 내용 주의
#### 2. 람다 표현식을 메서드 참조로 리팩터링하기
- 람다 표현식 대신 메서드 참조로 가독성 높이기
- 메서드명으로 코드의 의도를 명확하게
- sum, maximum 등 자주 사용하는 리듀싱 연산은 메서드 참조와 함께 사용할 수 있는 내장 헬퍼 메서드를 제공. Collectors API 사용.
#### 3. 명령형 데이터 처리를 스트림으로 리팩터링하기
- 반복자를 이용한 컬렉션 처리 코드를 스트림 API로 바꾸기
- 스트림은 쇼트서킷, 게으름이라는 최적화와 멀티코어아키텍처 활용에 유리

```java
// 1. 람다표현식 사용
Runnable r2 = () -> System.out.println("Hello");
// 2. 컬렉터 summingInt 사용
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
// 3. 반복하는 컬렉션 처리 코드는 스트림 API 이용
menu.parallelStream().filter(d -> d.getCalories() > 300).map(Dish::getName).collect(toList());
```

### 람다 표현식으로 코드 유연성 개선
람다 표현식 이용하려면 함수형 인터페이스 필요

#### 1. 조건부 연기 실행
- 특정 조건에서만 메시지가 생성될 수 있게 메시지 생성 과정 연기 가능
- log 메서드 : logger의 수준이 적절하게 설정되어 있을 때만 인수로 넘겨진 람다를 내부적으로 실행
- 클라이언트 코드에서 객체 상태를 자주 확인하거나 객체의 일부 메서드를 호출할 때, 내부적으로 객체 상태를 확인 후 메서드를 호출하도록 메서드 구현

#### 2. 실행 어라운드
- 매번 같은 준비, 종료 과정을 반복적으로 수행하는 코드가 있다면 이를 람다로 변환
- 준비, 종료 과정을 처리하는 로직을 재사용


## 9.2 람다로 객체지향 디자인 패턴 리팩터링하기
### 9.2.1 strategy (전략)
한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법
#### 구성
- 알고리즘을 나타내는 인터페이스 (Strategy 인터페이스)
- 다양한 알고리즘을 나타내는 한 개 이상의 인터페이스 구현 (ConcreateStrategyA, ConcreateStrategyB 같은 구체적인 구현 클래스)
- 전략 객체를 사용하는 한 개 이상의 클라이언트
#### 람다 표현식 사용
Strategy 인터페이스가 함수형 인터페이스이고 Predicate<String> 과 같은 함수 디스크립터를 갖고 있으면  
다양한 전략 구현하는 새 클래스 구현 필요 없이 람다 표현식 전달

### 9.2.2 template method (템플릿 메서드)
알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공  
이 알고리즘을 사용하고 싶은데 그대로는 안 되고 조금 고쳐야 하는 상황에 사용  
#### 구성
- abstract 클래스가 있음. 
- 각각의 지점이 이 추상클래스의 상속받아서 각자 추상 메서드를 원하는 동작을 수행하도록 구현.
#### 람다 표현식 사용
- 알고리즘의 개요를 만든 다음에 구현자가 원하는 기능을 추가할 수 있게 만들 수 있다.
- 람다나 메서드 참조로 알고리즘에 추가할 다양한 컴포넌트를 구현
- 추상 클래스를 상속 받지 않고 람다표현식으로 다양한 동작 추가 가능

### 9.2.3 observer (옵저버)
- 어떤 이벤트가 발생했을 때 한 객체(주제)가 다른 객체 리스트(옵저버)에 자동으로 알림을 보내야 하는 상황
- GUI 애플리케이션에서 자주 사용.
ex) 버튼 같은 GUI 컴포넌트에 옵저버를 설정 가능. 사용자가 버튼을 클릭하면 옵저버에 알림이 전달되고 정해진 동작이 수행.
#### 구성
- 다양한 옵저버를 그룹화할 Observer 인터페이스 (notify 같은 메서드 제공)
- 다른 동작을 수행하는 여러 옵저버들 (ConcreteObserverB, ConcreteObserverA 같은 구현 클래스)
- 주제 (새로운 옵저버를 등록하고 알려줌. 옵저버 관리)
#### 람다 표현식
- Observer 인터페이스를 구현하는 모든 클래스가 하나의 메서드(ex. notify)를 구현할 때 사용
- 옵저버를 명시적으로 인스턴스화하지 않고 람다 표현식을 직접 전달해서 실행할 동작 지정 가능

### 9.2.4 chain of responsibility (의무 체인)
- 작업 처리 객체의 체인(동작 체인 등)을 만들 때  
- 한 객체가 어떤 작업을 처리한 다음에 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 처리한 다음에 또 다른 객체로 전달
- 템플릿 메서드 디자인 패턴이 사용됨
#### 구성
- 다음으로 처리할 객체 정보를 유지하는 필드를 포함하는 작업 처리 추상 클래스
#### 람다 표현식
함수 체인 (함수 조합) 과 비슷. 작업 처리 객체를 UnaryOperator<String> 형식의 인스턴스로 표현. andThen 메서드로 이들 함수를 조합해서 체인. 

### 9.2.5 factory (팩토리)
인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때

## 9.3 람다 테스팅
### 9.3.1 보이는 람다 표현식의 동작 테스팅
- 람다는 익명(결국 익명 함수)이므로 테스트 코드 이름을 호출할 수 없다.
- 필요하다면 람다를 필드에 저장해서 재사용할 수 있으며 람다의 로직을 테스트할 수 있다
- 메서드를 호출하는 것처럼 람다를 사용 가능
```java
public class Point {
    public final static Comparator<Point> compareByXAndThenY = 
            comparing(Point::getX).thenComparing(Point::getY);
}

@Test
public void testComparingTwoPoints() throws Exception {
    Point p1 = new Point(10, 15);
    Point p2 = new Point(10, 20);
    int result = Point.compareByXAndThenY.compare(p1 , p2);
    assertTrue(result < 0);
}
```
### 9.3.2 람다를 사용하는 메서드의 동작에 집중하라
람다 표현식을 사용하는 메서드의 동작을 테스트해서 람다를 공개하지 않으면서도 람다 표현식 검증 가능

### 9.3.3 복잡한 람다를 개별 메서드로 분할하기
람다 표현식을 메서드 참조로 바꾸기. 그러면 일반 메서드 테스트하듯 람다 표현식 테스트 가능

### 9.3.4 고차원 함수 테스팅
#### 고차원 함수
함수를 인수로 받거나 다른 함수를 반환하는 메서드
메서드가 람다를 인수로 받는다면 다른 람다로 메서드의 동작을 테스트 가능

## 9.4 디버깅
### 9.4.1 스택 트레이스 확인
#### 스택 프레임
프로그램이 메서드를 호출할 때마다 프로그램에서의 호출 위치, 호출할 때의 인수값, 호출된 메서드의 지역 변수 등을 포함한 호출 정보가 생성되고 스택 프레임에 저장  
#### 스택 트레이스
프로그램이 멈췄다면 프로그램이 어떻게 멈추게 되었는지 프레임별로 보여주는 스택 트레이스 얻을 수 있음.  
문제가 발생한 지점에 이르게 된 메서드 호출 리스트 얻을 수 있고, 문제 발생 이유 이해 가능.
#### 람다와 스택 트레이스
- 람다 표현식과 관련한 스택 트레이스는 이해하기 어려울 수 있다
- 람다 표현식은 이름이 없으므로 컴파일러가 람다를 참조하는 이름을 만들어냄 ex) lambda$main$0

### 9.4.2 정보 로깅

## 9.5 마치며
- 람다 표현식으로 가독성이 좋고 더 유연한 코드를 만들 수 있다. 
- 익명 클래스는 람다 표현식으로 바꾸는 것이 좋다. 하지만 이때 this, 변수 섀도 등 미묘하게 의미상 다른 내용이 있음을 주의하자. 
- 메서드 참조로 람다 표현식보다 더 가독성이 좋은 코드를 구현할 수 있다. 
- 반복적으로 컬렉션을 처리하는 루틴은 스트림 API로 대체할 수 있을지 고려하는 것이 좋다. 
- 람다 표현식으로 전략, 템플릿 메서드, 옵저버, 의무 체인, 팩토리 등의 객체지향 디자인 패턴에서 발생하는 불필요한 코드를 제거할 수 있다. 
- 람다 표현식도 단위 테스트를 수행할 수 있다. 하지만 람다 표현식 자체를 테스트하는 것보다는 람다 표현식이 사용되는 메서드의 동작을 테스트하는 것이 바람직하다.
- 복잡한 람다 표현식은 일반 메서드로 재구현할 수 있다. 
- 람다 표현식을 사용하면 스택 트레이스를 이해하기 어려워진다. 
- 스트림 파이프라인에서 요소를 처리할 때 peek 메서드로 중간값을 확인할 수 있다
