# Chapter 15. CompletableFuture와 리액티브 프로그래밍 컨셉의 기초
> Keyword : Thread, Future, 동시성 API, 비동기 API, 동시 컴퓨팅의 박스와 채널 뷰, CompletableFuture, 플로 API, 리액티브 프로그래밍, 리액티브 시스템

## 15.1 동시성을 구현하는 자바 지원의 진화
#### 동시성과 병렬성
- 동시성 : 단일 코어 머신에서 발생할 수 있는 프로그래밍 속성. 실행이 서로 겹칠 수 있다.
- 병렬성 : 병렬 실행을 하드웨어 수준에서 지원

#### 자바 진화 과정
1. 자바는 Runnable과 Thread를 동기화도니 클래스와 메서드를 이용해 잠갔음
2. 자바 5 : 스레드 실행과 태스크 제출 분리하는 ExecutorService 인터페이스 지원. Runnable, Thread의 변형을 반환하는 Callable<T>, Future<T>, 제네릭 지원
3. 자바 7 : 분할 그리고 정복 알고리즘의 포크/조인 구현 지원하는 java.util.concurrent.RecursiveTask
4. 자바 8 : 스트림과 람다 지원에 기반한 병렬 프로세싱
5. 자바 9 : 분산 비동기 프로그래밍 명시적으로 지원

### 15.1.1 스레드와 높은 수준의 추상화
- 병렬 스트림 반복은 명시적으로 스레드를 사용하는 것에 비해 높은 수준의 개념
- 스트림을 이용해 스레드 사용 패턴을 추상화
### 15.1.2 Executor와 스레드 풀
자바 5는 Executor 프레임워크와 스레드 풀을 통해 자바 프로그래머가 태스크 제출과 실행을 분리할 수 있는 기능을 제공
#### 스레드의 문제
- 자바 스레드는 직접 운영체제 스레드에 접근한다. 
- 비싼 비용과 스레드의 숫자가 제한되어 있는 게 문제
#### 스레드 풀
- 자바 ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공
-  newFixedThreadPool 같은 팩토리 메서드로 스레드 풀 만들 수 있다
- 워커 스레드라 불리는 nThreads를 포함하는 ExecutorService 만들고 이를 스레드 풀에 저장
- 스레드 풀에서 사용하지 않은 스레드로 제출도니 태스크를 먼저 온 순서대로 실행한다.
- 태스크 실행이 종료되면 스레드를 풀로 반환
- 프로그래머가 태스크(Runnable or Callable)를 제공하면 스레드가 이를 실행
- 하드웨어에 맞는 수의 태스크를 유지하면서 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다
#### 스레드 풀 주의할 점
- k 스레드를 가진 스레드 풀은 오직 k만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장
- 자바 프로그램은 main이 반환하기 전에 모든 스레드의 작업이 끝나길 기다린다. 프로그램 종료 전 모든 스레드 풀 종료하기

### 15.1.3 스레드의 다른 추상화 : 중첩되지 않은 메서드 호출
#### 엄격한 포크/조인
- 태스크나 스레드가 메서드 호출 안에서 시작되면 그 메서드 호출은 반환하지 않고 작업이 끝나기를 기다림
- 스레드 생성과 join()이 한 쌍처럼 중첩된 메서드 호출 내에 추가
#### 여유로운 포크/조인
- 시작된 태스크를 내부 호출이 아니라 외부 호출에서 종료하도록 기다림
#### 비동기 메서드
- 메서드 호출자에 기능을 제공하도록 메서드가 반환된 후에도 만들어진 태스크 실행이 계속되는 메서드
#### 데몬 스레드
- 애플리케이션이 종료될 때 강제 종료됨
- 데이터 일관성을 파괴하지 않는 동작 수행 시 유용하게 활용 가능
- setDaemon() 메서드로 데몬/비데몬으로 구분 가능
- main() 메서드는 모든 비데몬 스레드가 종료될 때까지 프로그램을 종료하지 않고 기다림

### 15.1.4 스레드에 무엇을 바라는가?
프로그램을 작은 태스크 단위로 구조화

## 15.2 동기 API와 비동기 API
#### 병렬성 이용
1. 외부 반복(명시적 for 루프)을 내부 반복(스트림)으로 바꾸기
2. 스트림에 parallel() 메서드 이용
### 15.2.1 Future 형식 API
- 자바 5에서 소개된 Future는 자바 8의 CompletableFuture로 이들을 조합할 수 있게 됨
### 15.2.2 리액티브 형식 API
- if-then-else를 이용해 적절한 락을 이용해 두 콜백이 모두 호출되었는지 확인한 다음 println을 호출해 원하는 기능을 수행
- 리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었으므로 Future를 이용하는 것이 더 적절
### 15.2.3 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주
태스크를 블록하는 것보다는 다음 작업을 태스크로 제출하고 현재 태스크는 종료하는 것이 바람직
#### sleep()
- 사람과 상호작용하거나 속도 제한에 사용. 
- 하지만 스레드는 잠들어도 시스템 자원 점유. 다른 태스크가 시작되지 못하게 막으므로 자원 소비.
#### 블록 동작
- 다른 태스크가 어떤 동작을 완료하기를 기다리는 동작 / 외부 상호작용을 기다리는 동작
- 절대 태스크에서 기다리는 일을 만들지 말거나 아니면 코드에서 예외를 일으켜서 처리

### 15.2.4 현실성 확인
- 모든 API를 비동기로 만드는 것을 따지지 말고 개선된 동시성 API를 사용해보기
- 네트워크 서버의 블록/비블록 API를 일관적으로 제공하는 Netty 라이브러리 등 사용
### 15.2.5 비동기 API에서 예외는 어떻게 처리하는가?
- Future를 구현한 CompletableFuture에서는 런타임 get() 메서드에 예외를 처리할 수 있는 기능과 예외에서 회복할 수 있도록 exceptionally()도 제공
- 리액티브 형식의 비동기 API에서는 return 대신 기존 콜백이 호출. 예외가 발생했을 때 실행될 추가 콜백을 만들어 인터페이스를 바꿔야 함
- 자바 9 플로 API에서는 여러 콜백을 한 객체로 감쌈. 콜백이 여러 개면 한 객체로 이 메서드를 감싸는 게 좋다.

## 15.3 박스와 채널 모델
- 동시성 모델을 가장 잘 설계하고 개념화하려면 그림이 필요
- 박스로 원하는 연산을 표현
- 생각과 코드를 구조화할 수 있고 대규모 시스템 구현의 추상화 수준을 높일 수 있다
- 병렬성을 직접 프로그래밍하는 관점을 콤비네이터를 이용해 내부적으로 작업을 처리하는 관점으로 바꿔준다
- 시스템이 커지면 각각 많은 박스와 채널 다이어그램이 등장하고 각 박스는 내부적으로 자신만의 박스와 채널을 사용하게 된다
- 복잡해지면 하드웨어의 병렬성을 제대로 활용하지 못하거나 데드락 가능.
- ex. 발행-구독 에서 구독을 채널로 발행자와 구독자를 박스로 표현

## 15.4 CompletableFuture와 콤비네이터를 이용한 동시성
### Future 인터페이스
- 동시 코딩 작업을 Future 인터페이스로 생각하도록 유도
- 실행해서 get()으로 결과를 얻을 수 있는 Callable로 만들어짐
- 한번만 실행해서 결과를 제공

### CompletableFuture
- 자바8에서는 Future 인터페이스의 구현인 CompletableFuture로 Future를 조합할 수 있다.
- 실행할 코드 없이 Future를 만들 수 있게 허용함
- complete()메서드로 나중에 어떤 값을 이용해 다른 스레드가 이를 완료할 수 있고 get()으로 값 얻을 수 있게 허용

### CompletableFuture와 콤비네이터
- 많은 수의 Future를 사용해야 할 때 CompletableFuture와 콤비네이터를 이용해서 get()에서 블록하지 않을 수 있다. 
- 병렬 실행의 효율성 높이고 데드락 피할 수 있음

## 15.5 발행-구독 그리고 리액티브 프로그래밍
### 리액티브 프로그래밍
- 여러 Future 같은 객체를 통해 여러 결과 제공
- 반응하는 부분이 존재
- 자바 9에서는 java.util.concurrent.Flow의 인터페이스에 발행-구독 모델을 적용해서 제공

### 플로 API
- 구독자가 구독할 수 있는 발행자 / 이 연결을 구독(subscription) / 이 연결을 이용해 메시지 (또는 이벤트)를 전송
- 여러 컴포넌트가 한 구독자로 구독 가능 
- 한 컴포넌트는 여러 개별 스트림을 발행 가능
- 한 컴포넌트는 여러 구독자에 가입 가능

### Publisher<T>, Subscriber<T>
```java
interface Publisher<T> { 
    void subscribe(Subscriber<? super T> subscriber); // 통신할 구독자를 인수로 받음
}
interface Subscriber<T> {
    void onNext(T t); // 정보를 전달할 단순 메서드
}
```
## 15.6 리액티브 시스템 vs 리액티브 프로그래밍

## 15.7 마치며
- 자바의 동시성 지원은 계속 진화해 왔으며 앞으로도 그럴 것이다. 스레드 풀은 보통 유용하지만 블록되는 태스크가 많아지면 문제가 발생한다.
- 메서드를 비동기(결과를 처리하기 전에 반환)로 만들면 병렬성을 추가할 수 있으며 부수적으로 루프를 최적화한다.
- 박스와 채널 모델을 이용해 비동기 시스템을 시각화할 수 있다.
- 자바 8 CompletableFuture 클래스와 자바 9 플로 API 모두 박스와 채널 다이어그램으로 표현할 수 있다.
- CompletableFuture 클래스는 한 번의 비동기 연산을 표현한다. 콤비네이터로 비동기 연산을 조합함으로 Future를 이용할 때 발생했던 기존의 블로킹 문제를 해결할 수 있다.
- 플로 API는 발행-구독 프로토콜, 역압력을 이용하면 자바의 리액티브 프로그래밍의 기초를 제공한다.
- 리액티브 프로그래밍을 이용해 리액티브 시스템을 구현할 수 있다.
