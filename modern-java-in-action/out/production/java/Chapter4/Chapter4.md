# 04. 정렬
> Keyword : 버블정렬, 선택정렬, 삽입정렬, 퀵 정렬, 병합정렬, 기수정렬

## 04-0 정렬
- 버블 : 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬
- 선택 : 대상에서 가장 크거나 작은 데이터 찾아가 선택을 반복하면서 정렬
- 삽입 : 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬
- 퀵 : pivot 값을 선정해 해당 값을 기준으로 정렬
- 병합 : 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬
- 기수 : 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬

## 04-1 버블 정렬
- 두 인접한 데이터의 크기를 비교해 정렬
- O(n^2)으로 속도 느림
- 루프를 돌면서 인접한 데이터 간의 swap 연산으로 정렬

## 04-2 선택 정렬
- 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
- O(n^2)으로 속도 느리고 복잡. -> 잘 사용 안 함
- 최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와 swap

## 04-3 삽입 정렬
- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬
- O(n^2)으로 속도 느림. 구현 쉬움
- 선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입
- 삽입 위치 탐색할 때 이진 탐색 같은 탐색 알고리즘 쓰면 시간 복잡도 줄일 수 있음

## 04-4 퀵 정렬
- 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해서 정렬
- 기준값이 어떻게 선정되는지가 중요. O(nlogn)
- pivot을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬
- 재귀 형태로 구현

### 퀵 정렬 구현하기
1. 중간 위치를 pivot으로 설정하고 맨 앞의 값과 swap
2. pivot 제외한 그룹에서 왼쪽 끝을 i, 오른쪽 끝을 j로 설정
3. j를 이동 - j보다 pivot이 크면 j--
4. i를 이동 - i가 pivot보다 작으면서 j가 더 크면 i++
5. i, j 멈추면 swap
6. 이 때, i, j가 만나면 해당 위치와 pivot swap
7. 분리 집합에서 다시 pivot 선정해서 분리집합 1개 이하 될 때까지 반복

## 04-5 병합 정렬
- 분할 정복(divide and conquer) 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘
- O(nlogn)
- 2개씩 그룹을 합치며 정렬

### 2개의 그룹을 병합하는 과정
- 투 포인터 개념을 사용하여 왼쪽, 오른쪽 그룹 병합
- 왼쪽 포인터와 오른쪽 포인터의 값을 비교하여 작은 값을 결과 배열에 추가하고 포인터를 오른쪽으로 1칸 이동

## 04-6 기수 정렬
- 값을 비교하지 않는 특이한 정렬
- 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교
- O(kn) : k는 데이터의 자릿수
- 시간복잡도에 가장 짧은 정렬

### 기수 정렬의 핵심 이론
- 기수 정렬은 10개의 큐 이용. 각 큐는 값의 자릿수를 대표.

### 기수 정렬 수행 방식
- 일의 자릿수를 기준으로 배열 원소를 큐에 집어넣음
- 0번째 큐부터 9번째 큐까지 pop
- 십의 자릿수를 기준으로 배열 원소 큐에 집어넣고 pop
- 마지막 자릿수 기준으로 정렬할 때까지 반복
- 이 때, 앞의 자릿수에서 정렬된 순서 기준으로 다음 자릿수에 저장하는 것이 중요!

### 기수 정렬과 구간합
- 일반적인 기수 정렬은 우선순위 큐를 사용해서 구현
- 하지만 시간복잡도를 느리게 하는 요소가 있음
- 구간 합을 이용하는 방법으로도 구현 가능

