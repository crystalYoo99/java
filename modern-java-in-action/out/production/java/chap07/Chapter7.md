# Chapter 7. 병렬 데이터 처리와 성능
> Keyword : 병렬 스트림, parallel(), 포크/조인 프레임워크, Spliterator

## 7.1 병렬 스트림
- 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림
- 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.
- 컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성
- 병렬 스트림은 내부적으로 ForkJoinPool을 사용

### 7.1.1 순차 스트림을 병렬 스트림으로 변환하기 (parallel 메서드 / sequential 메서드)
#### parallel() : 순차 -> 병렬 / sequential() : 병렬 -> 순차
최종적으로 호출된 메서드가 전체 파이프라인에 영향 미침

#### parallel()
- 순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리
- 순차 스트림에 parallel 호출해도 스트림 자체에는 변화 없음.
- 내부적으로는 parallel 호출 시 이후 연산이 병렬로 수행해야 함을 의미하는 불리언 플래그 설정됨.
```java
public long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
        .limit(n)
        .parallel() //스트림을 병렬 스트림으로 변환
        .reduce(0L, Long::sum);
}
```

### 7.1.2 스트림 성능 측정
#### 자바 마이크로벤치마크 하이니스 (JMH) 라이브러리
- 간단하고, 어노테이션 기반 방식을 지원하며, 안정적으로 자바프로그램이나 자바 가상 머신을 대상으로 하는 다른 언어용 벤치마크 구현 가능
- Maven 빌드 도구를 사용한다면 메이븐 빌드 과정을 정의하는 pom.xml 파일에 몇 가지 의존성을 추가해 프로젝트에서 JMH를 사용가능
- 기본적으로 20+20회 프로그램 반복 실행함.
- @Benchmark

#### 더 특화된 메서드 사용
- 특화되지 않은 스트림을 처리할 때는 오토박싱, 언박싱 등의 오버헤드를 수반
- 올바른 자료구조를 선택해야 병렬실행도 최적의 성능을 발휘할 수 있다

### 7.1.3 병렬 스트림의 올바른 사용법
*병렬 스트림과 병렬 계산에서는 공유된 가변 상태를 피해야 한다*
병렬 스트림 사용에서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용해서 발생.  
예를 들어 누적자가 있으면 여러 스레드에서 동시에 누적자에 접근해서 데이터 레이스 문제 발생.

### 7.1.4 병렬 스트림 효과적으로 사용하기
#### 스트림 소스에 따른 분해성
- 훌륭함 : ArrayList, IntStream.range
- 좋음 : HashSet, TreeSet
- 나쁨 : LinkedList, Stream.iterate
- 
#### 병렬 스트림의 효과적 사용에 대한 힌트
- 확신이 서지 않으면 직접 측정 : 적절한 벤치마크로 직접 순차와 병렬 성능을 측정. 
- 박싱을 주의 (기본형 특화 스트림 사용) : 자동 박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소.
- 병렬 스트림에서 성능이 떨어지는 연산 주의 : 요소의 순서에 의존하는 연산(limit, findFirst). unordered 호출 시 비정렬된 스트림 얻을 수 있다. 요소 순서가 상관없으면 비정렬된 스트림에 limit 호출이 더 효율적. 
- 스트림에서 수행하는 전체 파이프라인 연산 비용 고려 : N(요소수)*Q(요소 하나 처리 비용) --> Q가 높아지면 병렬 스트림으로 성능 개선 가능을 의미
- 소량의 데이터에는 도움 되지 않음 : 병렬화 과정에서도 부가 비용이 생긴다. 이를 상쇄 못함.
- 스트림 구성 자료구조가 적절한지 확인 : ArrayList(요소 탐색 안하고 리스트 분할 가능)가 LinkedList(모든 요소 탐색해야 분할)보다 효율적으로 분할 가능. / range 팩토리 메서드로 만든 기본형 스트림도 쉽게 분해 가능. / 커스텀 Spliterator를 구현해서 분해 과정 제어 가능.
- 스트림 특성과 파이프라인 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다. : SIZED 스트림은 정확히 같은 크기의 두 스트림으로 분할 가능. 반면 필터 연산이 있으면 스트림의 길이를 예측할 수 없으므로 효과적으로 스트림을 병렬 처리할 수 있을지 알 수 없게 된다
- 최종연산의 병합 과정 비용 살펴보기 : 병합 과정(ex. Collector의  combiner()) 의 비용이 비싸면 서브스트림의 부분 결과 합치는 과정이 오히려 부정적 영향.

## 7.2 포크/조인 프레임워크
- 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음, 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계
- ExecutorService 인터페이스 : 서브태스크를 스레드 풀(ForkJoinPool)의 작업자 스레드에 분산 할당
- 자바 7에 추가된 포크/조인 프레임워크와 내부적인 병렬 스트림 처리는 어떤 관계가 있는가

### 7.2.1 RecursiveTask 활용
- 스레드 풀을 이용하려면 RecursiveTask<R>의 서브클래스를 만들어야 한다.
- R : 병렬화된 태스크가 생성하는 결과 형식 또는 결과가 없을 때는 RecursiveAction 형식

#### 추상메서드 compute()
태스크를 서브태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브태스크의 결과를 생산할 알고리즘을 정의

```java
protected abstract R compute();

// divide-and-conquer 알고리즘의 병렬화 버전 

//if (태스크가 충분히 작거나 더 이상 분할할 수 없으면) {
//    순차적으로 태스크 계산
//} else {
//    태스크를 두 서브태스크로 분할 
//    태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출함 
//    모든 서브태스크의 연산이 완료될 때까지 기다림 
//    각 서브태스크의 결과를 합침
//}
```
#### ForkJoinPool
- 일반적으로 애플리케이션에서는 둘 이상의 ForkJoinPool을 사용하지 않음
- 소프트웨어의 필요한 곳에서 언제든 가져다 쓸 수 있도록 ForkJoinPool을 한 번만 인스턴스화해서 정적 필드에 싱글턴으로 저장
- ForkJoinPool을 만들면서 인수가 없는 디폴트 생성자를 이용했는데, 이는 JVM에서 이용할 수 있는 모든 프로세서가 자유롭게 풀에 접근할 수 있음을 의미한다
- RecursiveTask<R>의 서브클래스(ex. ForkJoinSumCalculator)를 ForkJoinPool에 전달하면 풀의 스레드가 compute 메서드를 실행하면서 작업 수행

### 7.2.2 포크/조인 프레임워크를 제대로 사용하는 방법
- join 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때까지 호출자를 블록시킨다. 따라서 두 서브태스크가 모두 시작된 다음에 join을 호출.
- RecursiveTask 내에서는 ForkJoinPool의 invoke 메서드 사용 금지. 대신 compute나 fork 메서드를 직접 호출할 수 있다. 순차 코드에서 병렬 계산을 시작할 때만 invoke 사용
- 서브태스크에 fork 메서드를 호출해서 ForkJoinPool의 일정을 조절. 한쪽 작업에는 fork를 호출하는 것보다는 compute를 호출하는 것이 효율적. 
- 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어렵다
- 멀티코어에 포크/조인 프레임워크를 사용하는 것이 순차 처리보다 무조건 빠를 거라는 생각은 버려야 한다

### 7.2.3 작업 훔치기
- 코어 개수와 관계없이 적절한 크기로 분할된 많은 태스크를 포킹하는 것이 바람직
- 풀에 있는 작업자 스레드의 태스크를 재분배하고 균형을 맞출 때 작업 훔치기 알고리즘을 사용
1) ForkJoinPool의 모든 스레드를 거의 공정하게 분할.
2) 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서 작업이 끝날 때마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리
3) 이때 자신에게 할당된 태스크를 더 빨리 처리해서 할일이 없어진 스레드는 유휴 상태로 바뀌는 것이 아니라 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다.
4) 모든 태스크가 작업 끝낼 때까지, 즉, 모든 큐가 빌 때까지 과정 반복.
-> 태스크 크기를 작게 나눠야 스레드 간의 작업 부하가 비슷해짐

## 7.3 Spliterator 인터페이스
- Spliterator는 ‘분할할 수 있는 반복자 splitable iterator’라는 의미
- Iterator처럼 소스의 요소 탐색 기능을 제공하지만 Spliterator는 병렬 작업에 특화
- 여러 청크를 병렬로 처리하기 전에 병렬 스트림이 요소를 여러 청크로 분할하는 방법
```java
public interface Spliterator<T> { 
    boolean tryAdvance(Consumer<? super T> action);
    Spliterator<T> trySplit();
    long estimateSize();
    int characteristics();
}
// T는 Spliterator에서 탐색하는 요소의 형식
```
### Spliterator의 메서드
- tryAdvance : Spliterator의 요소를 하나씩 순차적으로 소비하면서 탐색해야 할 요소가 남아있으면 참을 반환 (일반적인 Iterator 동작)
- trySplit : 반복될 자료구조를 분할하는 로직을 포함하므로 Spliterator에서 가장 중요한 메서드. Spliterator의 일부 요소(자신이 반환한 요소)를 분할해서 두 번째 Spliterator를 생성
- estimateSize : 탐색해야 할 요소 수 정보. 더 쉽고 공평하게 Spliterator 분할 가능
- characteristics : Spliterator 자체의 특성 집합을 포함하는 int를 반환

### Spliterator  특성
ORDERED / DISTINCT / SORTED / SIZED / NON-NULL / IMMUTABLE / CONCURRENT / SUBSIZED

### 분할 과정
재귀적으로 발생. 분할 과정은 characteristics 메서드로 정의하는 Spliterator 특성에 영향 받음
1) 첫 번째 Spliterator에 trySplit을 호출하면 두 번째 Spliterator가 생성
2) 두 개의 Spliterator에 trySplit를 다시 호출하면 네 개의 Spliterator가 생성
3) trySplit의 결과가 null 될 때까지 반복
4) Spliterator에서 호출한 모든 trySplit의 결과가 null이면 재귀 분할 과정 종료

### 늦은 바인딩
Spliterator는 첫 번째 탐색 시점, 첫 번째 분할 시점, 또는 첫 번째 예상 크기(estimatedSize) 요청 시점에 요소의 소스를 바인딩  
Spliterator에서 자료구조 분할 과정 제어 가능


## 7.4 마치며
- 내부 반복을 이용하면 명시적으로 다른 스레드를 사용하지 않고도 스트림을 병렬로 처리할 수 있다.
- 간단하게 스트림을 병렬로 처리할 수 있지만 항상 병렬 처리가 빠른 것은 아니다. 병렬 소프트웨어 동작 방법과 성능은 직관적이지 않을 때가 많으므로 병렬 처리를 사용했을 때 성능을 직접 측정해봐야 한다.
- 병렬 스트림으로 데이터 집합을 병렬 실행할 때 특히 처리해야 할 데이터가 아주 많거나 각 요소를 처리하는 데 오랜 시간이 걸릴 때 성능을 높일 수 있다
- 가능하면 기본형 특화 스트림을 사용하는 등 올바른 자료구조 선택이 어떤 연산을 병렬로 처리하는 것보다 성능적으로 더 큰 영향을 미칠 수 있다.
- 포크/조인 프레임워크에서는 병렬화할 수 있는 태스크를 작은 태스크로 분할한 다음에 분할된 태스크를 각각의 스레드로 실행하며 서브태스크 각각의 결과를 합쳐서 최종 결과를 생산한다.
- Spliterator는 탐색하려는 데이터를 포함하는 스트림을 어떻게 병렬화할 것인지 정의한다