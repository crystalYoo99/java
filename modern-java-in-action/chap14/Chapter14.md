# Chapter 14. 자바 모듈 시스템
> Keyword : 자바 모듈 시스템, declarations, requires, exports, 모듈화, JDK, 메이븐 빌드

## 14.1 압력 : 소프트웨어 유추
### 14.1.1 관심사분리
- 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙
- 각각의 부분, 서로 거의 겹치지 않는 코드 그룹으로 분리
- 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있다
- 쉬운 협업 / 재사용 쉬움 / 유지보수 쉬움
### 14.1.2 정보 은닉
- 세부 구현을 숨기도록 장려하는 원칙
- 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다.
- 코드를 관리하고 보호하는 데 유용한 원칙
- 캡슐화 : 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있다
- 클래스 내의 컴포넌트에 적절하게 private 키워드를 사용했는지를 기준으로 컴파일러를 이용해 캡슐화를 확인
### 14.1.3 자바 소프트웨어
- 특정 문제와 관련된 패키지, 클래스, 인터페이스를 그룹으로 만들어 코드를 그룹화할 수 있다 
- UML 다이어그램 : 그룹 코드 간의 의존성을 시각적으로 보여줌. 소프트웨어 추론에 도움.

## 14.2 자바 모듈 시스템을 설계한 이유
### 14.2.1 모듈화의 한계
#### 제한된 가시성 제어
- 가시성 접근자. public / protected / 패키지수준 / private
- 패키지 간 가시성 제어 기능은 거의 없음
#### 클래스 경로
- 클래스를 모두 컴파일한 후 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용할 수 있다. 그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽는다.
- 하지만 클래스 경로와 JAR 조합에는 약점 존재
  - 클래스 경로에 같은 클래스 구분하는 버전 개념 없음
  - 클래스 경로는 명시적인 의존성 지원하지 않음
- Maven, Gradle 같은 빌드 도구들이 이런 문제 해결에 도움
### 14.2.2 거대한 JDK
- 자바 프로그램을 만들고 실행하는 데 도움을 주는 도구의 집합
- javac (컴파일), java(자바 애플리케이션 로드하고 실행), JDK 라이브러리 (입출력, 런타임 지원제공) 등
- JDK에서 필요한 부분만 골라 사용하고, 클래스 경로를 쉽게 유추할 수 있으며, 플랫폼을 진화시킬 수 있는 강력한 캡슐화를 제공할 자바 모듈 시스템 설계 필요
### 14.2.3 OSGi와 비교

## 14.3 자바 모듈 : 큰 그림
### 모듈
- 새로운 자바 프로그램 구조 단위. 
- module이라는 새 키워드에 이름과 바디를 추가해서 정의
### 모듈 디스크립터
- module-info.java 라는 파일에 저장됨
- 보통 패키지와 같은 폴더에 위치함 
- 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 패키지 중 한 개만 외부로 노출시킴
#### 모듈 디스크립터 구조
module 모듈명 / exports 패키지명 / requires 모듈명  
exports는 돌출부, requires는 패인 부분으로 생각 가능

## 14.4 자바 모듈 시스템으로 애플리케이션 개발하기
### 14.4.1 애플리케이션 셋업
- 캡슐화와 추론. 모듈 시스템의 여러 부분이 두드러질 수 있도록 잘게 분해
### 14.4.2 세부적인 모듈화와 거친 모듈화
- 시스템을 모듈화할 때 모듈 크기를 결정.모듈화는 소프트웨어 부식의 적
- 세부적인 모듈화 : 모든 패키지가 자신의 모듈 가짐. 설계 비용 증가.
- 거친 모듈화 : 한 모듈이 시스템의 모든 패키지 포함. 모듈화의 장점 잃음.

### 14.4.3 자바 모듈 시스템 기초
#### module-info.java
- 모듈 디스크립터
- 모듈의 소스 코드 파일 루트에 위치해야 하며 모듈의 의존성 그리고 어떤 기능을 외부로 노출할지를 정의

## 14.5 여러 모듈 활용하기
```java
module expenses.readers {
    requires java.base; // 패키지명 아니고 모듈명
  
    exports com.example.expenses.readers; //모듈명 아니고 패키지명
    exports com.example.expenses.readers.file;
    exports com.example.expenses.readers.http;
}
```
### exports
- 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만든다
- 기본적으로 모듈 내의 모든 것은 캡슐화된다
### requires
- 의존하고 있는 모듈을 지정
- 기본적으로 모든 모듈은 java.base라는 플랫폼 모듈에 의존. 정의 필요 없음.
- java.base 외의 모듈을 임포트할 때 requires를 사용
### 이름 정하기
- 오라클은 패키지명처럼 인터넷 도메인명을 역순으로 모듈의 이름을 정하도록 권고
- 모듈명은 노출된 주요 API 패키지와 이름이 같아야 한다

## 14.6 컴파일과 패키징
1. pom.xml 추가
- 각 모듈은 독립적으로 컴파일되므로 자체적으로 각각이 한 개의 프로젝트
- 전체 프로젝트 빌드를 조정할 수 있게 각 모든 모듈의 부모 모듈에도 pom.xml 추가
2. 모듈 디스크립터 (module-info.java)는 src/main/java 디렉터리에 위치
3. 각 모듈의 pom.xml 설정
4. 빌드 과정을 가이드할 전역 pom.xml 설정

## 14.7 자동 모듈
- 자바는 JAR를 자동 모듈이라는 형태로 적절하게 변환한다. 
- 모듈 경로상에 있으나 module-info 파일을 가지지 않은 모든 JAR는 자동 모듈이 된다.
- 자동 모듈은 암묵적으로 자신의 모든 패키지를 노출시킨다. 
- 자동 모듈의 이름은 JAR 이름을 이용해 정해진다.
- jar 도구의 --describe-module 인수로 자동으로 정해지는 이름 바꿀 수 있다.

## 14.8 모듈 정의와 구문들
- requires : 컴파일 타임과 런타임에 한 모듈이 다른 모듈에 의존함을 정의 (패키지명)
- exports : 지정한 패키지를 다른 모듈에서 이용할 수 있도록 공개 형식으로 만든다 (모듈명)
- requires transitive : 다른 모듈이 제공하는 공개 형식을 한 모듈에서 사용할 수 있다고 지정
- exports to : 사용자에게 공개할 기능을 제한
- open : 모든 패키지를 다른 모듈에 반사적으로 접근 허용
- opens : 필요한 개별 패키지만 개방
- provides, uses : provides 구문으로 서비스 제공자를 uses 구문으로 서비스 소비자를 지정

## 14.9 더 큰 예제 그리고 더 배울 수 있는 방법

## 14.10 마치며
- 관심사분리와 정보 은닉은 추론하기 쉬운 소프트웨어를 만드는 중요한 두 가지 원칙이다.
- 자바 9 이전에는 각각의 기능을 담당하는 패키지, 클래스, 인터페이스로 모듈화를 구현했는데 효과적인 캡슐화를 달성하기에는 역부족이었다.
- 클래스 경로 지옥 문제는 애플리케이션의 의존성을 추론하기 더욱 어렵게 만들었다.
- 자바 9 이전의 JDK는 거대했으며 높은 유지 비용과 진화를 방해하는 문제가 존재했다.
- 자바 9에서는 새로운 모듈 시스템을 제공하는데 module-info.java 파일은 모듈의 이름을 지정하며 필요한 의존성(requires)과 공개 API(exports)를 정의한다.
- requires 구문으로 필요한 다른 모듈을 정의할 수 있다. 
- exports 구문으로 특정 패키지를 다른 모듈에서 사용할 수 있는 공개 형식으로 지정할 수 있다.
- 인터넷 도메인명을 역순으로 사용하는 것이 권장 모듈 이름 규칙이다.
- 모듈 경로에 포함된 JAR 중에 module-info 파일을 포함하는 않는 모든 JAR는 자동 모듈이 된다.
- 자동 모듈은 암묵적으로 모든 패키지를 공개한다.
- 메이븐은 자바 9 모듈 시스템으로 구조화된 애플리케이션을 지원한다
