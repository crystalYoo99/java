# Chapter 14. 자바 모듈 시스템
> Keyword : 자바 모듈 시스템, declarations, requires, exports, 모듈화, JDK, 메이븐 빌드

## 14.1 압력 : 소프트웨어 유추
### 14.1.1 관심사분리
- 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙
- 각각의 부분, 서로 거의 겹치지 않는 코드 그룹으로 분리
- 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있다
- 쉬운 협업 / 재사용 쉬움 / 유지보수 쉬움
### 14.1.2 정보 은닉
- 세부 구현을 숨기도록 장려하는 원칙
- 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다.
- 코드를 관리하고 보호하는 데 유용한 원칙
- 캡슐화 : 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있다
- 클래스 내의 컴포넌트에 적절하게 private 키워드를 사용했는지를 기준으로 컴파일러를 이용해 캡슐화를 확인
### 14.1.3 자바 소프트웨어
- 특정 문제와 관련된 패키지, 클래스, 인터페이스를 그룹으로 만들어 코드를 그룹화할 수 있다 
- UML 다이어그램 : 그룹 코드 간의 의존성을 시각적으로 보여줌. 소프트웨어 추론에 도움.

## 14.2 자바 모듈 시스템을 설계한 이유
### 14.2.1 모듈화의 한계
#### 제한된 가시성 제어
- 가시성 접근자. public / protected / 패키지수준 / private
- 패키지 간 가시성 제어 기능은 거의 없음
#### 클래스 경로
- 클래스를 모두 컴파일한 후 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용할 수 있다. 그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽는다.
- 하지만 클래스 경로와 JAR 조합에는 약점 존재
  - 클래스 경로에 같은 클래스 구분하는 버전 개념 없음
  - 클래스 경로는 명시적인 의존성 지원하지 않음
- Maven, Gradle 같은 빌드 도구들이 이런 문제 해결에 도움
### 14.2.2 거대한 JDK
- 자바 프로그램을 만들고 실행하는 데 도움을 주는 도구의 집합
- javac (컴파일), java(자바 애플리케이션 로드하고 실행), JDK 라이브러리 (입출력, 런타임 지원제공) 등
- JDK에서 필요한 부분만 골라 사용하고, 클래스 경로를 쉽게 유추할 수 있으며, 플랫폼을 진화시킬 수 있는 강력한 캡슐화를 제공할 자바 모듈 시스템 설계 필요
### 14.2.3 OSGi와 비교

## 14.3 자바 모듈 : 큰 그림
### 모듈
- 새로운 자바 프로그램 구조 단위. 
- module이라는 새 키워드에 이름과 바디를 추가해서 정의
### 모듈 디스크립터
- module-info.java 라는 파일에 저장됨
- 보통 패키지와 같은 폴더에 위치함 
- 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 패키지 중 한 개만 외부로 노출시킴
#### 모듈 디스크립터 구조
module 모듈명 / exports 패키지명 / requires 모듈명  
exports는 돌출부, requires는 패인 부분으로 생각 가능

## 14.4 자바 모듈 시스템으로 애플리케이션 개발하기
### 14.4.1 애플리케이션 셋업
- 캡슐화와 추론. 모듈 시스템의 여러 부분이 두드러질 수 있도록 잘게 분해
### 14.4.2 세부적인 모듈화와 거친 모듈화
- 시스템을 모듈화할 때 모듈 크기를 결정.모듈화는 소프트웨어 부식의 적
- 세부적인 모듈화 : 모든 패키지가 자신의 모듈 가짐. 설계 비용 증가.
- 거친 모듈화 : 한 모듈이 시스템의 모든 패키지 포함. 모듈화의 장점 잃음.

### 14.4.3 자바 모듈 시스템 기초
#### module-info.java
- 모듈 디스크립터
- 모듈의 소스 코드 파일 루트에 위치해야 하며 모듈의 의존성 그리고 어떤 기능을 외부로 노출할지를 정의
